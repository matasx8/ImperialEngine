#version 450

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_NV_mesh_shader: require
#extension GL_GOOGLE_include_directive: require
#extension GL_ARB_shader_draw_parameters: require
#extension GL_EXT_nonuniform_qualifier : require

//#include "prefix.h"
#include "DescriptorSet0.h"
#include "DescriptorSet1.h"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

out taskNV block
{
	uint meshletIndices[32];
};

/**
 * For backface culling with orthographic projection, use the following formula to reject backfacing clusters:
 *   dot(view, cone_axis) >= cone_cutoff
 *
 * For perspective projection, you can the formula that needs cone apex in addition to axis & cutoff:
 *   dot(normalize(cone_apex - camera_position), cone_axis) >= cone_cutoff
 */
 // Above snippet from meshoptimizer.h
 // apparent this is wrong for perspective projection as I suspected
 // look at RT-rendering 19.3 for more info
bool coneCull(vec4 cone, vec3 view)
{
	return dot(cone.xyz, view) > cone.w;
}

shared uint meshletCount;

void main()
{
	uint ti = gl_LocalInvocationID.x;
	uint mgi = gl_WorkGroupID.x;
	uint mi = mgi * 32 + ti;

	meshletCount = 0;

	memoryBarrierShared();

	// Transform meshlet normal cone to clip space
	vec4 cone_model_space = vec4(meshlets[mi].cone.xyz, 1);
	mat4 model_matrix = drawData[drawDataIndices[gl_DrawIDARB]].Transform;
	vec4 cone_clip_space = uboViewProjection.PV * model_matrix * cone_model_space;
	 
	// In Vulkan clip space the camera view direction is -z
	vec3 view_dir_clip_space = vec3(0, 0, -1);

	// w component is cone half angle
	vec4 cone = vec4(cone_clip_space.xyz, meshlets[mi].cone.w);

	bool visible = !coneCull(cone, view_dir_clip_space);

	if(visible)
	{
		uint index = atomicAdd(meshletCount, 1);

		meshletIndices[index] = mi;
	}

	memoryBarrierShared();

	if (ti == 0)
	{
		uint drawDataIndex = drawDataIndices[gl_DrawIDARB];
		uint taskCount = min(meshletCount, drawData[drawDataIndex].taskCount - gl_WorkGroupID.x * 32);

		gl_TaskCountNV = taskCount;
	}
}