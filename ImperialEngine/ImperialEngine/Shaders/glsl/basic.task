#version 450

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_NV_mesh_shader: require
#extension GL_GOOGLE_include_directive: require
#extension GL_ARB_shader_draw_parameters: require
#extension GL_EXT_nonuniform_qualifier : require

//#include "prefix.h"
#include "DescriptorSet0.h"
#include "DescriptorSet1.h"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

out taskNV block
{
	uint meshletIndices[32];
	uint drawIdx;
};

bool is_inside_view_frustum(uint idx)
{
    BoundingVolume bv = meshlets[idx].boundingVolume;

    vec4 mCenter = vec4(bv.center, 1.0); // BV center in Model space
    vec4 wCenter = drawData[drawDataIndices[gl_DrawIDARB]].Transform * mCenter;           // BV center in World space

    float diameter = bv.diameter;

    for (int i = 0; i < 6; i++)
    {
        // Compute signed distance of center of BV from plane.
        // Plane equation: Ax + By + Cy + d = 0
        // Inserting our point into equation gives us the signed distance for wCenter
        float signedDistance = dot(globals.frustum[i], wCenter);

        // Negative result already lets us know that point is in negative half space of plane
        // If it's less than 0 + (-diameter) then BV is outside VF
        if(signedDistance < -diameter)
            return false;
    }
    return true;
}

// Real-Time Rendering 4th edition, 19.3
bool coneCull(vec4 cone, vec3 center, vec3 cam_pos, float radius)
{
	//return dot(normalize(cam_pos - center), cone.xyz) >= cone.w + radius / length(center - cam_pos);
	return dot(center - cam_pos, cone.xyz) >= cone.w * length(center - cam_pos) + radius;
}

shared uint meshletCount;

void main()
{
	uint ti = gl_LocalInvocationID.x;
	uint mi = gl_GlobalInvocationID.x + drawData[drawDataIndices[gl_DrawIDARB]].meshletBufferOffset;

	meshletCount = 0;
	drawIdx = drawDataIndices[gl_DrawIDARB];

	memoryBarrierShared();

	mat4 model_matrix = drawData[drawDataIndices[gl_DrawIDARB]].Transform;
	
	vec4 decoded_cone = vec4(meshlets[mi].cone[0], meshlets[mi].cone[1], meshlets[mi].cone[2], meshlets[mi].cone[3]);
	mat4 rotmat = globals.View * model_matrix;
	rotmat[3] = vec4(0,0,0,1);
	vec4 cone = vec4((rotmat * vec4(decoded_cone.xyz, 1)).xyz, decoded_cone.w);

	//vec4 decoded_cone = vec4(int(meshlets[mi].cone[0]) / 127.0, int(meshlets[mi].cone[1]) / 127.0, int(meshlets[mi].cone[2]) / 127.0, int(meshlets[mi].cone[3]) / 127.0);
	
	
	// Transform BV to view space
	BoundingVolume bv = meshlets[mi].boundingVolume;
	vec3 bv_center_world_space = (globals.View * model_matrix * vec4(bv.center, 1.0)).xyz;

	// Camera position in View space is at the origin
	vec4 cam_pos = vec4(0,0,0,0);

	bool notOutOfBounds = gl_GlobalInvocationID.x < drawData[drawDataIndices[gl_DrawIDARB]].taskCount;

	bool visible = notOutOfBounds && !coneCull(cone, bv_center_world_space.xyz, cam_pos.xyz, bv.diameter / 2.0);

	bool is_inside_VF = true;
	//if (visible)
	//	is_inside_VF = is_inside_view_frustum(mi);

	if(visible && is_inside_VF)
	{
		uint index = atomicAdd(meshletCount, 1);

		meshletIndices[index] = mi;
	}

	memoryBarrierShared();

	if (ti == 0)
	{
		uint drawDataIndex = drawDataIndices[gl_DrawIDARB];
		uint taskCount = min(meshletCount, drawData[drawDataIndex].taskCount - gl_WorkGroupID.x * 32);

		gl_TaskCountNV = taskCount;
	}
}